""" World graph planner implementation. """

import time
import itertools

from .planner_base import PathPlannerBase
from ..utils.motion import Path, reduce_waypoints_polygon
from ..utils.pose import Pose
from ..utils.search_graph import SearchGraph, Node


class WorldGraphPlannerPolygon:
    """
    Polygon representation based implementation of world graph planner.
    """

    def __init__(
        self,
        world=None,
        collision_check_step_dist=0.025,
        max_connection_dist=None,
        compress_path=False,
    ):
        """
        Creates an instance of a world graph planner.

        :param world: World object to use in the planner.
        :type world: :class:`pyrobosim.core.world.World`
        :param collision_check_step_dist: Step size for discretizing collision checking.
        :type collision_check_step_dist: float
        :param max_connection_dist: Maximum connection distance between nodes.
        :type max_connection_dist: float
        :param compress_path: If true, tries to shorten the path with polygon-based collision checks.
        :type compress_path: bool
        """
        # Parameters
        self.collision_check_step_dist = collision_check_step_dist
        self.max_connection_dist = max_connection_dist
        self.world = world
        self.compress_path = compress_path

        self.planning_time = 0.0
        self.latest_path = Path()

        self.reset()

    def reset(self):
        """
        Initializes the graph from the entity nodes in the world linked to this planner.
        """
        from ..core.locations import Location

        # Create a search graph from the nodes in the world.
        self.graph = SearchGraph(color=[0, 0.4, 0.8], color_alpha=0.5, use_planner=True)
        for entity in itertools.chain(
            self.world.rooms, self.world.hallways, self.world.locations
        ):
            entity.add_graph_nodes()
            if isinstance(entity, Location):
                for spawn in entity.children:
                    for node in spawn.graph_nodes:
                        self.graph.add_node(node)
                        self.connect_neighbors(node)
            else:
                for node in entity.graph_nodes:
                    self.graph.add_node(node)
                    self.connect_neighbors(node)

    def connect_neighbors(self, node):
        """
        Connect a node to all nodes within connection distance.

        :param node: Node to try add to the graph.
        :type node: :class:`pyrobosim.utils.search_graph.Node`
        """
        for other in self.graph.nodes:
            if node == other:
                continue
            if self.world.is_connectable(
                node.pose,
                other.pose,
                self.collision_check_step_dist,
                self.max_connection_dist,
            ):
                self.graph.add_edge(node, other)

    def plan(self, start, goal):
        """
        Plans a path from start to goal.

        :param start: Start pose or graph node.
        :type start: :class:`pyrobosim.utils.pose.Pose` /
            :class:`pyrobosim.utils.search_graph.Node`
        :param goal: Goal pose or graph node.
        :type goal: :class:`pyrobosim.utils.pose.Pose` /
            :class:`pyrobosim.utils.search_graph.Node`
        :return: Path from start to goal.
        :rtype: :class:`pyrobosim.utils.motion.Path`
        """
        # Reset the path and time
        self.latest_path = Path()
        self.planning_time = 0.0
        # Create the start and goal nodes
        if isinstance(start, Pose):
            start = Node(start, parent=None)
        self.graph.add_node(start)
        if isinstance(goal, Pose):
            goal = Node(goal, parent=None)
        self.graph.add_node(goal)

        self.connect_neighbors(start)
        self.connect_neighbors(goal)

        # Find a path from start to goal nodes
        t_start = time.time()
        self.latest_path = self.graph.find_path(start, goal)
        if self.compress_path:
            compressed_poses = reduce_waypoints_polygon(
                self.world, self.latest_path.poses, self.collision_check_step_dist
            )
            self.latest_path.set_poses(compressed_poses)
        self.latest_path.fill_yaws()
        self.planning_time = time.time() - t_start
        self.graph.remove_node(start)
        self.graph.remove_node(goal)
        return self.latest_path

    def get_graphs(self):
        """Returns the graphs generated by the planner if any."""
        return [self.graph]


class WorldGraphPlanner(PathPlannerBase):
    """Factory class for world graph path planner."""

    def __init__(self, **planner_config):
        """
        Creates an instance of world graph planner.
        """
        super().__init__()

        self.impl = None

        if planner_config.get("grid", None):
            raise NotImplementedError(
                "Grid based world graph planner is not supported. "
            )
        else:
            self.impl = WorldGraphPlannerPolygon(**planner_config)

    def plan(self, start, goal):
        """
        Plans a path from start to goal.

        :param start: Start pose.
        :type start: :class:`pyrobosim.utils.pose.Pose`
        :param goal: Goal pose.
        :type goal: :class:`pyrobosim.utils.pose.Pose`
        :return: Path from start to goal.
        :rtype: :class:`pyrobosim.utils.motion.Path`
        """
        start_time = time.time()
        self.latest_path = self.impl.plan(start, goal)
        self.planning_time = time.time() - start_time
        self.graphs = self.impl.get_graphs()
        return self.latest_path
